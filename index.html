<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手势控制花朵生成器</title>
    <style>
        html, body {
            overflow: hidden;
            padding: 0;
            margin: 0;
            background: #000000;
        }
        .container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column-reverse;
            align-items: start;
        }
        .controls {
            z-index: 10;
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 15px;
        }
        .control-btn {
            font-family: sans-serif;
            font-size: 15px;
            color: white;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            padding: 8px 15px;
            cursor: pointer;
            user-select: none;
            opacity: 0.8;
            transition: all 0.3s ease;
        }
        .control-btn:hover {
            opacity: 1;
            background: rgba(255, 255, 255, 0.2);
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
        }
        .cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 5;
            transition: transform 0.1s ease;
        }
        .cursor.active {
            transform: translate(-50%, -50%) scale(1.5);
            background-color: rgba(255, 100, 255, 0.7);
            box-shadow: 0 0 20px rgba(255, 100, 255, 0.8);
        }
        /* 移除页面标题和说明文字的样式 */
        .video-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 640px;
            height: 480px;
            border-radius: 10px;
            overflow: hidden;
            opacity: 0.95;
            transition: all 0.3s ease;
            z-index: 3;
            border: 3px solid rgba(255, 255, 255, 0.25);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.6);
        }
        .video-container:hover {
            opacity: 1;
            transform: scale(1.02);
        }
        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        #hand-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }
        .status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-family: sans-serif;
        }
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
            font-family: sans-serif;
        }
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        /* 移除媒体查询中的文字样式 */
        @media all and (min-width: 640px) {
            /* 空的媒体查询，保留以备将来使用 */
        }
    </style>
</head>
<body>
    <div class="loading">
        <div class="loading-spinner"></div>
    </div>
 
    <div class="container">
        <canvas id="canvas"></canvas>
        <div class="cursor" id="cursor"></div>
        <div class="controls">
            <div class="control-btn" id="cleanBtn"></div>
            <div class="control-btn" id="toggleVideoBtn"></div>
        </div>
    </div>
     
    <div class="video-container" id="videoContainer">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="hand-canvas"></canvas>
        <div class="status" id="status"></div>
    </div>
     
    <!-- 移除页面标题和说明文字 -->
 
    <script type="x-shader/x-fragment" id="fragmentShader">
        #define PI 3.14159265359
        uniform float u_ratio;
        uniform vec2 u_cursor;
        uniform float u_stop_time;
        uniform float u_clean;
        uniform vec2 u_stop_randomizer;
        uniform sampler2D u_texture;
        varying vec2 vUv;
 
        // --------------------------------
        // 2D noise
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
        float snoise(vec2 v) {
            const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
            vec2 i = floor(v + dot(v, C.yy));
            vec2 x0 = v - i + dot(i, C.xx);
            vec2 i1;
            i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
            vec4 x12 = x0.xyxy + C.xxzz;
            x12.xy -= i1;
            i = mod289(i);
            vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
            vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
            m = m*m;
            m = m*m;
            vec3 x = 2.0 * fract(p * C.www) - 1.0;
            vec3 h = abs(x) - 0.5;
            vec3 ox = floor(x + 0.5);
            vec3 a0 = x - ox;
            m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
            vec3 g;
            g.x = a0.x * x0.x + h.x * x0.y;
            g.yz = a0.yz * x12.xz + h.yz * x12.yw;
            return 130.0 * dot(m, g);
        }
 
        float get_flower_shape(vec2 _p, float _pet_n, float _angle, float _outline) {
            _angle *= 3.;
            _p = vec2(_p.x * cos(_angle) - _p.y * sin(_angle),
            _p.x * sin(_angle) + _p.y * cos(_angle));
            float a = atan(_p.y, _p.x);
            float flower_sectoral_shape = pow(abs(sin(a * _pet_n)), .4) + .25;
            vec2 flower_size_range = vec2(.03, .1);
            float size = flower_size_range[0] + u_stop_randomizer[0] * flower_size_range[1];
            float flower_radial_shape = pow(length(_p) / size, 2.);
            flower_radial_shape -= .1 * sin(8. * a); // add noise
            flower_radial_shape = max(.1, flower_radial_shape);
            flower_radial_shape += smoothstep(0., 0.03, -_p.y + .2 * abs(_p.x));
            float grow_time = step(.25, u_stop_time) * pow(u_stop_time, .3);
            float flower_shape = 1. - smoothstep(0., flower_sectoral_shape, _outline * flower_radial_shape / grow_time);
            flower_shape *= (1. - step(1., grow_time));
            return flower_shape;
        }
 
        float get_stem_shape(vec2 _p, vec2 _uv, float _w, float _angle) {
            _w = max(.004, _w);
            float x_offset = _p.y * sin(_angle);
            x_offset *= pow(3. * _uv.y, 2.);
            _p.x -= x_offset;
 
            // add horizontal noise to the cursor coordinale
            float noise_power = .5;
            float cursor_horizontal_noise = noise_power * snoise(2. * _uv * u_stop_randomizer[0]);
            cursor_horizontal_noise *= pow(dot(_p.y, _p.y), .6);// moise to be zero at cursor
            cursor_horizontal_noise *= pow(dot(_uv.y, _uv.y), .3);// moise to be zero at bottom
            _p.x += cursor_horizontal_noise;
 
            // vertical line through the cursor point (_p.x)
            float left = smoothstep(-_w, 0., _p.x);
            float right = 1. - smoothstep(0., _w, _p.x);
            float stem_shape = left * right;
 
            // make it grow + don't go up to the cursor point
            float grow_time = 1. - smoothstep(0., .2, u_stop_time);
            float stem_top_mask = smoothstep(0., pow(grow_time, .5), .03 -_p.y);
            stem_shape *= stem_top_mask;
 
            // stop drawing once done
            stem_shape *= (1. - step(.17, u_stop_time));
            return stem_shape;
        }
 
        void main() {
            vec3 base = texture2D(u_texture, vUv).xyz;
            vec2 uv = vUv;
            uv.x *= u_ratio;
            vec2 cursor = vUv - u_cursor.xy;
            cursor.x *= u_ratio;
 
            vec3 stem_color = vec3(.1 + u_stop_randomizer[0] * .6, .6, .2);
            vec3 flower_color = vec3(.6 + .5 * u_stop_randomizer[1], .1, .9 - .5 * u_stop_randomizer[1]);
 
            float angle = .5 * (u_stop_randomizer[0] - .5);
 
            float stem_shape = get_stem_shape(cursor, uv, .003, angle);
            stem_shape += get_stem_shape(cursor + vec2(0., .2 + .5 * u_stop_randomizer[0]), uv, .003, angle);
            float stem_mask = 1. - get_stem_shape(cursor, uv, .004, angle);
            stem_mask -= get_stem_shape(cursor + vec2(0., .2 + .5 * u_stop_randomizer[0]), uv, .004, angle);
 
            float petals_back_number = 1. + floor(u_stop_randomizer[0] * 2.);
            float angle_offset = -(2. * step(0., angle) - 1.) * .1 * u_stop_time;
            float flower_back_shape = get_flower_shape(cursor, petals_back_number, angle + angle_offset, 1.5);
            float flower_back_mask = 1. - get_flower_shape(cursor, petals_back_number, angle + angle_offset, 1.6);
 
            float petals_front_number = 2. + floor(u_stop_randomizer[1] * 2.);
            float flower_front_shape = get_flower_shape(cursor, petals_front_number, angle, 1.);
            float flower_front_mask = 1. - get_flower_shape(cursor, petals_front_number, angle, .95);
 
            vec3 color = base;
            color *= stem_mask;
            color *= flower_back_mask;
            color *= flower_front_mask;
 
            color += (stem_shape * stem_color);
            color += (flower_back_shape * (flower_color + vec3(0., .8 * u_stop_time, 0.)));
            color += (flower_front_shape * flower_color);
            color.r *= 1. - (.5 * flower_back_shape * flower_front_shape);
            color.b *= 1. - (flower_back_shape * flower_front_shape);
 
            color *= u_clean;
            gl_FragColor = vec4(color, 1.);
        }
    </script>
 
    <script type="x-shader/x-vertex" id="vertexShader">
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = vec4(position, 1.);
        }
    </script>
 
    <script type="module">
        import * as THREE from "https://cdn.skypack.dev/three@0.133.1/build/three.module";
         
        // 加载 MediaPipe Hands 模型
        const loadMediaPipeHands = async () => {
            // 添加脚本标签方式加载库，更可靠
            const loadScript = (src) => {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = src;
                    script.onload = resolve;
                    script.onerror = () => reject(new Error(`Failed to load script: ${src}`));
                    document.head.appendChild(script);
                });
            };
             
            try {
                // 只加载必要的库，不加载drawing_utils
                await Promise.all([
                    loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.min.js"),
                    loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1632432234/camera_utils.min.js")
                ]);
                 
                return new window.Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
                    }
                });
            } catch (error) {
                // 尝试备用CDN
                console.log("尝试使用备用CDN...");
                await Promise.all([
                    loadScript("https://unpkg.com/@mediapipe/hands@0.4.1646424915/hands.min.js"),
                    loadScript("https://unpkg.com/@mediapipe/camera_utils@0.3.1632432234/camera_utils.min.js")
                ]);
                 
                return new window.Hands({
                    locateFile: (file) => {
                        return `https://unpkg.com/@mediapipe/hands@0.4.1646424915/${file}`;
                    }
                });
            }
        };
         
        // 主函数
        const main = async () => {
            const canvasEl = document.querySelector("#canvas");
            const cleanBtn = document.querySelector("#cleanBtn");
            const toggleVideoBtn = document.querySelector("#toggleVideoBtn");
            const videoContainer = document.querySelector("#videoContainer");
            const webcamEl = document.querySelector("#webcam");
            const handCanvas = document.querySelector("#hand-canvas");
            const handCtx = handCanvas.getContext("2d");
            const cursorEl = document.querySelector("#cursor");
            const statusEl = document.querySelector("#status");
            const loadingEl = document.querySelector(".loading");
             
            // 初始化指针位置
            const pointer = {
                x: 0.5,
                y: 0.5,
                clicked: false,
                vanishCanvas: false
            };
             
            // 用于存储拇指和食指间的距离
            let currentPinchDistance = 1.0;
             
            // 设置光标初始位置
            cursorEl.style.left = `${pointer.x * window.innerWidth}px`;
            cursorEl.style.top = `${pointer.y * window.innerHeight}px`;
             
            // 初始化 Three.js 渲染器
            let basicMaterial, shaderMaterial;
            let renderer = new THREE.WebGLRenderer({
                canvas: canvasEl,
                alpha: false
            });
            renderer.setClearColor(0x000000, 1.0);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
             
            let sceneShader = new THREE.Scene();
            let sceneBasic = new THREE.Scene();
            let camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 10);
            let clock = new THREE.Clock();
             
            let renderTargets = [
                new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight),
                new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight)
            ];
             
            // 确保渲染目标使用黑色清除颜色
            renderTargets.forEach(target => {
                target.texture.format = THREE.RGBAFormat;
            });
             
            createPlane();
            updateSize();
             
            // 初始化渲染目标为黑色
            renderer.setRenderTarget(renderTargets[0]);
            renderer.clear();
            renderer.setRenderTarget(renderTargets[1]);
            renderer.clear();
            renderer.setRenderTarget(null);
             
            window.addEventListener("resize", () => {
                updateSize();
            });
             
            // 手势识别变量
            let hands;
            let camera_utils;
            let indexFingerPos = { x: 0, y: 0 };
            let thumbPos = { x: 0, y: 0 };
            let pinchDetected = false;
            let lastPinchTime = 0;
            const pinchCooldown = 500; // 点击冷却时间（毫秒）
             
            try {
                // 加载 MediaPipe Hands 模型
                hands = await loadMediaPipeHands();
                 
                // 设置手势识别参数
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                 
                // 不再需要设置MediaPipe全局变量，因为我们使用自定义绘制函数
                 
                // 处理手势识别结果
                hands.onResults(onHandResults);
                 
                // 初始化摄像头
                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: 640,
                            height: 480,
                            facingMode: "user"
                        }
                    });
                     
                    webcamEl.srcObject = stream;
                     
                    // 等待视频元素加载完成
                    await new Promise((resolve) => {
                        webcamEl.onloadedmetadata = () => {
                            resolve();
                        };
                    });
                     
                    // 启动摄像头
                    camera_utils = new window.Camera(webcamEl, {
                        onFrame: async () => {
                            await hands.send({ image: webcamEl });
                        }
                    });
                    camera_utils.start();
                     
                    statusEl.textContent = "手势识别已启动";
                    loadingEl.style.display = "none";
                } else {
                    throw new Error("浏览器不支持摄像头访问");
                }
            } catch (error) {
                console.error("初始化失败:", error);
                statusEl.textContent = "初始化失败: " + error.message;
                // 简化错误显示
                loadingEl.innerHTML = `
                    <div style="margin-top:20px">
                        <button style="padding: 10px 20px; background: #333; color: white; border: none; border-radius: 4px; cursor: pointer;"
                        onclick="window.location.reload()"></button>
                    </div>
                `;
            }
             
            // 处理手势识别结果
            function onHandResults(results) {
                // 清除手部绘制画布
                handCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);
                 
                // 设置手部画布尺寸与视频匹配
                if (handCanvas.width !== webcamEl.videoWidth || handCanvas.height !== webcamEl.videoHeight) {
                    handCanvas.width = webcamEl.videoWidth;
                    handCanvas.height = webcamEl.videoHeight;
                }
                 
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                     
                    // 获取食指指尖位置 (索引8)
                    const indexFinger = landmarks[8];
                    indexFingerPos = {
                        x: 1 - indexFinger.x, // 水平翻转坐标
                        y: indexFinger.y
                    };
                     
                    // 获取拇指指尖位置 (索引4)
                    const thumb = landmarks[4];
                    thumbPos = {
                        x: 1 - thumb.x, // 水平翻转坐标
                        y: thumb.y
                    };
                     
                    // 计算拇指和食指之间的距离
                    const distance = Math.hypot(
                        indexFingerPos.x - thumbPos.x,
                        indexFingerPos.y - thumbPos.y
                    );
                     
                    // 保存距离供绘制函数使用
                    currentPinchDistance = distance;
                     
                    // 检测捏合手势（拇指和食指靠近）
                    const now = Date.now();
                    if (distance < 0.05) { // 距离阈值
                        if (!pinchDetected && now - lastPinchTime > pinchCooldown) {
                            pinchDetected = true;
                            lastPinchTime = now;
                             
                            // 触发点击事件
                            pointer.clicked = true;
                            cursorEl.classList.add("active");
                             
                            // 300毫秒后移除活跃状态
                            setTimeout(() => {
                                cursorEl.classList.remove("active");
                            }, 300);
                        }
                    } else {
                        pinchDetected = false;
                    }
                     
                    // 绘制手部骨架
                    drawHandLandmarks(handCtx, landmarks, distance);
                     
                    // 更新光标位置
                    pointer.x = indexFingerPos.x;
                    pointer.y = indexFingerPos.y;
                     
                    // 更新可视光标位置
                    cursorEl.style.left = `${pointer.x * window.innerWidth}px`;
                    cursorEl.style.top = `${pointer.y * window.innerHeight}px`;
                     
                    // 不再显示状态文本
                } else {
                    // 不再显示状态文本
                }
            }
             
            // 绘制手部骨架和关键点（自定义实现，不依赖drawing_utils库）
            function drawHandLandmarks(ctx, landmarks, pinchDistance) {
                // 定义手部连接线
                const connections = [
                    [0, 1], [1, 2], [2, 3], [3, 4], // 拇指
                    [0, 5], [5, 6], [6, 7], [7, 8], // 食指
                    [0, 9], [9, 10], [10, 11], [11, 12], // 中指
                    [0, 13], [13, 14], [14, 15], [15, 16], // 无名指
                    [0, 17], [17, 18], [18, 19], [19, 20], // 小指
                    [5, 9], [9, 13], [13, 17] // 掌心连接
                ];
                 
                // 绘制连接线
                ctx.strokeStyle = '#00FF00';
                ctx.lineWidth = 4;
                 
                connections.forEach(([i, j]) => {
                    if (landmarks[i] && landmarks[j]) {
                        const x1 = landmarks[i].x * ctx.canvas.width;
                        const y1 = landmarks[i].y * ctx.canvas.height;
                        const x2 = landmarks[j].x * ctx.canvas.width;
                        const y2 = landmarks[j].y * ctx.canvas.height;
                         
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                });
                 
                // 特别绘制拇指和食指之间的线（类似virtual_light_controller.py）
                if (landmarks[4] && landmarks[8]) {
                    const x1 = landmarks[4].x * ctx.canvas.width;
                    const y1 = landmarks[4].y * ctx.canvas.height;
                    const x2 = landmarks[8].x * ctx.canvas.width;
                    const y2 = landmarks[8].y * ctx.canvas.height;
                     
                    // 始终使用红色线，但根据距离调整亮度和粗细
                    const isPinching = pinchDistance < 0.05;
                     
                    if (isPinching) {
                        // 捏合状态 - 鲜红色粗线
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 5;
                    } else {
                        // 非捏合状态 - 也是红色，但亮度随距离变化
                        const intensity = Math.max(0, Math.min(1, 1.0 - pinchDistance * 5));
                        const redValue = Math.floor(155 + 100 * intensity);
                        ctx.strokeStyle = `rgb(${redValue}, 50, 50)`;
                        ctx.lineWidth = 3 + 2 * intensity;
                    }
                     
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                     
                    // 在线的中间显示距离
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    ctx.font = '20px Arial';
                    ctx.fillStyle = 'white';
                    // 添加背景使文字更易读
                    const distText = `${pinchDistance.toFixed(3)}`;
                    const textWidth = ctx.measureText(distText).width;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(midX - textWidth/2 - 5, midY - 25, textWidth + 10, 25);
                    ctx.fillStyle = 'white';
                    ctx.fillText(distText, midX - textWidth/2, midY - 10);
                }
                 
                // 绘制关键点
                ctx.fillStyle = '#FF0000';
                 
                landmarks.forEach((landmark, index) => {
                    const x = landmark.x * ctx.canvas.width;
                    const y = landmark.y * ctx.canvas.height;
                     
                    // 拇指和食指指尖大一些
                    const radius = (index === 4 || index === 8) ? 8 : 4;
                     
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, 2 * Math.PI);
                    ctx.fill();
                });
                 
                // 添加坐标标签
                ctx.font = '18px Arial';
                ctx.fillStyle = 'white';
                 
                // 只为关键点添加坐标标签
                const keyPoints = [0, 4, 8, 12, 16, 20]; // 手腕、各指尖
                keyPoints.forEach(index => {
                    if (landmarks[index]) {
                        const x = landmarks[index].x * ctx.canvas.width;
                        const y = landmarks[index].y * ctx.canvas.height;
                        const label = `${index}:(${(landmarks[index].x).toFixed(2)}, ${(landmarks[index].y).toFixed(2)})`;
                        ctx.fillText(label, x + 15, y);
                    }
                });
            }
             
            // 清除画布
            cleanBtn.addEventListener("click", cleanCanvas);
            function cleanCanvas() {
                pointer.vanishCanvas = true;
                setTimeout(() => {
                    pointer.vanishCanvas = false;
                }, 50);
            }
             
            // 切换视频显示/隐藏
            toggleVideoBtn.addEventListener("click", () => {
                if (videoContainer.style.display === "none") {
                    videoContainer.style.display = "block";
                } else {
                    videoContainer.style.display = "none";
                }
            });
             
            // 创建渲染平面
            function createPlane() {
                shaderMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        u_stop_time: { type: "f", value: 0 },
                        u_stop_randomizer: {
                            type: "v2",
                            value: new THREE.Vector2(Math.random(), Math.random())
                        },
                        u_cursor: { type: "v2", value: new THREE.Vector2(pointer.x, pointer.y) },
                        u_ratio: { type: "f", value: window.innerWidth / window.innerHeight },
                        u_texture: { type: "t", value: null },
                        u_clean: { type: "f", value: 1 }
                    },
                    vertexShader: document.getElementById("vertexShader").textContent,
                    fragmentShader: document.getElementById("fragmentShader").textContent
                });
                 
                basicMaterial = new THREE.MeshBasicMaterial();
                const planeGeometry = new THREE.PlaneGeometry(2, 2);
                const planeBasic = new THREE.Mesh(planeGeometry, basicMaterial);
                const planeShader = new THREE.Mesh(planeGeometry, shaderMaterial);
                sceneBasic.add(planeBasic);
                sceneShader.add(planeShader);
            }
             
            // 渲染循环
            function render() {
                shaderMaterial.uniforms.u_clean.value = pointer.vanishCanvas ? 0 : 1;
                shaderMaterial.uniforms.u_texture.value = renderTargets[0].texture;
                 
                if (pointer.clicked) {
                    shaderMaterial.uniforms.u_cursor.value = new THREE.Vector2(
                        pointer.x,
                        1 - pointer.y
                    );
                    shaderMaterial.uniforms.u_stop_randomizer.value = new THREE.Vector2(
                        Math.random(),
                        Math.random()
                    );
                    shaderMaterial.uniforms.u_stop_time.value = 0;
                    pointer.clicked = false;
                }
                shaderMaterial.uniforms.u_stop_time.value += clock.getDelta();
                 
                // 确保清除颜色为黑色
                renderer.setClearColor(0x000000, 1.0);
                renderer.setRenderTarget(renderTargets[1]);
                renderer.clear();
                renderer.render(sceneShader, camera);
                 
                basicMaterial.map = renderTargets[1].texture;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(sceneBasic, camera);
                 
                let tmp = renderTargets[0];
                renderTargets[0] = renderTargets[1];
                renderTargets[1] = tmp;
                 
                requestAnimationFrame(render);
            }
             
            // 更新尺寸
            function updateSize() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                 
                shaderMaterial.uniforms.u_ratio.value = width / height;
                renderer.setSize(width, height);
                 
                renderTargets.forEach(target => {
                    target.setSize(width, height);
                });
            }
             
            // 启动渲染循环
            render();
        };
         
        // 启动应用
        main().catch(error => {
            console.error("应用启动失败:", error);
            // 简化错误显示
            document.querySelector(".loading").innerHTML = `
                <div style="margin-top:20px">
                    <button style="padding: 10px 20px; background: #333; color: white; border: none; border-radius: 4px; cursor: pointer;"
                    onclick="window.location.reload()"></button>
                </div>
            `;
        });
    </script>
</body>
</html>
